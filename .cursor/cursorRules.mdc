---
description: 
globs: 
alwaysApply: true
---
Design for Modularity:
Organize code into clear, self-contained units based on responsibility and domain. Separate high-level systems (like game scenes, UI, or audio), mid-level components (such as player logic or enemy behavior), and low-level utilities (helpers, constants). This promotes readability, maintainability, and scalability, especially in growing projects.

Encourage Clear Purpose and Intention:
Ensure each unit of code—whether a function, class, or module—has a single, well-defined role. Avoid mixing concerns. Favor expressive naming that communicates purpose unambiguously, even at the cost of brevity. Prioritize names that convey behavior, intent, and context over generic or abbreviated terms.

Leverage Structure to Communicate Architecture:
Use the framework’s architecture (e.g., lifecycle hooks or structural conventions) to reinforce code clarity. Group similar behaviors and entities to reflect their relationship and function within the system. This aids in visualizing the game's flow and logic at a glance and reduces mental overhead when navigating code.

Invest in Contextual Documentation:
Supplement your code with thoughtful, purpose-driven documentation. Annotate key abstractions, interfaces, and logic-heavy areas with explanations of why they exist, not just what they do. Good documentation tells the story behind the code, enabling smoother onboarding and faster debugging.

Write Understandable, Modular Code:
Aim for code that reads like a narrative. Functions should do one thing only, be easy to reason about, and be named in camelCase using self-explanatory, descriptive terms. Favor structure and naming that make the logic intuitive without needing to read every line. Write with modification and clarity in mind—future changes should be straightforward and safe due to clear separation of concerns and semantic naming.

